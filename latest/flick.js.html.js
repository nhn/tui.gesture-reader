tui.util.defineNamespace("fedoc.content", {});
fedoc.content["flick.js.html"] = "      <div id=\"main\" class=\"main\">\n\n\n\n    \n    <section>\n        <article>\n            <pre class=\"prettyprint source linenums\"><code>/**\n * @fileoverview discriminate flick event\n * @author NHN entertainment FE dev team. Jein Yi&lt;jein.yi@nhnent.com>\n */\n\n/**\n * Modules of Discrimination flick\n * @namespace Flick\n */\nvar Flick = /** @lends Flick */{\n    /**\n     * time is considered flick.\n     */\n    flickTime: 100,\n    /**\n     * width is considered flick.\n     */\n    flickRange: 300,\n    /**\n     * width is considered moving.\n     */\n    minDist: 10,\n    /**\n     * Reader type\n     */\n    type: 'flick',\n\n    /**\n     * Initialize Flicking\n     * @param {object} option Flick options\n     *  @param {number} [option.flickTime] Flick time, if in this time, do not check move distance\n     *  @param {number} [option.flickRange] Flick range, if not in time, compare move distance with flick ragne.\n     *  @param {number} [option.minDist] Minimum distance for check available movement.\n     */\n    initialize: function(option) {\n        this.flickTime = option.flickTime || this.flickTime;\n        this.flickRange = option.flickRange || this.flickRange;\n        this.minDist = option.minDist || this.minDist;\n    },\n\n    /**\n     * pick event type from eventData\n     * @api\n     * @param {object} eventData event Data\n     * @return {object}\n     * @example gestureReader.figure({\n     *      list : [{x: 0, y: 0}, {x: 100, y: 100}],\n     *      start: 0,\n     *      end: 50\n     * });\n     * => {\n     *      direction: 'SE',\n     *      isFlick: false\n     * }\n     */\n    figure: function(eventData) {\n        return {\n            direction : this.getDirection(eventData.list),\n            isFlick: this.isFlick(eventData)\n        }\n    },\n\n    /**\n     * return direction figured out\n     * @api\n     * @param {array} list eventPoint List\n     * @returns {string}\n     * @example gestureReader.getDirection([{x: 0, y: 0}, {x: 100, y: 100}]);\n     * => 'SE';\n     */\n    getDirection: function(list) {\n        var first = list[0],\n            final = list[list.length-1],\n            cardinalPoint = this.getCardinalPoints(first, final),\n            res = this.getCloseCardinal(first, final, cardinalPoint);\n\n        return res;\n    },\n    /**\n     * return cardinal points figured out\n     * @api\n     * @param {object} first start point\n     * @param {object} last end point\n     * @example gestureReader.getDirection({x: 0, y: 0}, {x: 100, y: 100});\n     * => 'SE';\n     */\n    getCardinalPoints: function(first, last) {\n        var verticalDist = first.y - last.y,\n            horizonDist = first.x - last.x,\n            NS = '',\n            WE = '';\n\n        if (verticalDist &lt; 0) {\n            NS = 'S';\n        } else if (verticalDist > 0) {\n            NS = 'N';\n        }\n\n        if (horizonDist &lt; 0) {\n            WE = 'E';\n        } else if (horizonDist > 0) {\n            WE = 'W';\n        }\n\n        return NS+WE;\n    },\n\n    /**\n     * return nearest four cardinal points\n     * @api\n     * @param {object} first start point\n     * @param {object} last end point\n     * @param {string} cardinalPoint cardinalPoint from getCardinalPoints\n     * @returns {string}\n     * @example gestureReader.getDirection({x: 0, y: 50}, {x: 100, y: 100});\n     * => 'W';\n     */\n    getCloseCardinal: function(first, last, cardinalPoint) {\n        var slop = (last.y - first.y) / (last.x - first.x),\n            direction;\n        if (slop &lt; 0) {\n            direction = slop &lt; -1 ? 'NS' : 'WE';\n        } else {\n            direction = slop > 1 ? 'NS' : 'WE';\n        }\n\n        direction = tui.util.getDuplicatedChar(direction, cardinalPoint);\n        return direction;\n    },\n\n    /**\n     * extract type of event\n     * @api\n     * @param {object} eventData event data\n     * @returns {string}\n     * @example\n     * reader.isFlick({\n     *      start: 1000,\n     *      end: 1100,\n     *      list: [\n     *            {\n     *                x: 10,\n     *                y: 10\n     *            },\n     *            {\n     *                x: 11,\n     *                y: 11\n     *            }\n     *      ]\n     * });\n     */\n    isFlick: function(eventData) {\n        var start = eventData.start,\n            end = eventData.end,\n            list = eventData.list,\n            first = list[0],\n            final = list[list.length - 1],\n            timeDist = end - start,\n            xDist = Math.abs(first.x - final.x),\n            yDist = Math.abs(first.y - final.y),\n            isFlick;\n\n        if (timeDist &lt; this.flickTime || xDist > this.flickRange || yDist > this.flickRange) {\n            isFlick = true;\n        } else {\n            isFlick = false;\n        }\n\n        return isFlick;\n    }\n};\n\nmodule.exports = Flick;\n</code></pre>\n        </article>\n    </section>\n\n\n\n</div>\n\n"